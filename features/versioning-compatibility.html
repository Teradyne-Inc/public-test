<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Backwards Compatibility | C# Reference Architecture </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Backwards Compatibility | C# Reference Architecture ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/TER-SEMITEST-InnerSource/cs-reference-architecture/blob/main/docs/features/versioning-compatibility.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../media/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="backwards-compatibility">Backwards Compatibility</h1>

<p>Compatibility is a sensitive topic for libraries that are widely used. The cost and effort to handle incompatible updates quickly scale with broad adoption, hence compatibility requirements need to be managed well.</p>
<p>Unfortunately, there is no perfect one-fits-all approach, and every solution comes with tradeoffs. Here's the model C#RA has selected, along with the logic chain why this is considered the best option.</p>
<h2 id="compatibility-philosophy">Compatibility Philosophy</h2>
<p>C#RA aims to minimize breaking changes while maintaining the flexibility to improve the library when necessary. The approach balances stability for existing users with the ability to deliver better solutions for new and evolving requirements.</p>
<h3 id="compatible-changes">Compatible Changes</h3>
<p>The following types of changes are considered compatible and can be made in minor version updates:</p>
<ul>
<li><strong>Bug fixes</strong> that correct unintended behavior without affecting legitimate use cases</li>
<li><strong>Additional functionality</strong> through new test blocks, test methods, or services</li>
<li><strong>Additional overloads</strong> for existing methods to support new use cases</li>
<li><strong>Additional optional parameters</strong> on existing methods with sensible defaults</li>
</ul>
<p>These changes preserve existing code behavior and require no modifications to test programs using previous versions of the library.</p>
<h3 id="incompatible-changes">Incompatible Changes</h3>
<p>While the strong preference is to avoid them, incompatible changes may be necessary when:</p>
<ul>
<li>Original design choices prove inadequate for real-world requirements</li>
<li>New requirements emerge that cannot be satisfied within the existing API structure</li>
<li>Maintaining compatibility would compromise the quality or usability of the solution</li>
</ul>
<p>When incompatible changes are required, they result in a new major version. The goal is to minimize such changes and introduce them only when the benefits clearly outweigh the migration effort for users.</p>
<h2 id="version-numbering">Version Numbering</h2>
<p>C#RA uses a <code>Major.Minor</code> version numbering scheme:</p>
<ul>
<li><strong>Minor version increments</strong> (e.g., 1.0 → 1.1) indicate compatible additions: new features, bug fixes, and enhancements that do not break existing code.</li>
<li><strong>Major version increments</strong> (e.g., 1.5 → 2.0) indicate incompatible changes that may require code modifications in test programs.</li>
</ul>
<p>Every release receives a version number. There are no unofficial versions, patches, or updates to existing releases. Each version is clearly identified through:</p>
<ul>
<li>Git tags in the repository</li>
<li>Assembly attributes in the compiled code</li>
<li>File names in release packages</li>
<li>API methods that return the version information</li>
</ul>
<p>Major version updates have no predefined schedule. They are introduced only when necessary, with the goal of keeping them rare.</p>
<h2 id="development-model">Development Model</h2>
<p>Development always targets the latest version of C#RA. There are no separate release branches, and features or fixes are not back-ported to previous releases.</p>
<p>This approach keeps the development effort focused and avoids the complexity of maintaining multiple active versions. Because C#RA is distributed as source code, users with specific requirements can apply changes to their local copy if needed.</p>
<h2 id="impact-on-test-programs">Impact on Test Programs</h2>
<p>The compatibility model is designed around how test programs actually use C#RA.</p>
<h3 id="version-independence">Version Independence</h3>
<p>Test programs include a specific version of C#RA, typically the latest available when the project starts. Each test program operates independently with its own copy of the library.</p>
<p>There is no global installation of C#RA that affects multiple test programs. Different test programs can use different C#RA versions without conflict.</p>
<h3 id="update-strategy">Update Strategy</h3>
<p>Released test programs running in production do not require updates to C#RA as long as they function correctly. Updates can be considered when:</p>
<ul>
<li>The test program needs modification for other reasons</li>
<li>New C#RA features would provide significant value</li>
<li>Bug fixes in C#RA address issues affecting the test program</li>
</ul>
<p>This means that incompatible C#RA updates have a limited scope. Only test programs that choose to upgrade are affected. Legacy programs continue to work with their embedded C#RA version.</p>
<h3 id="migration-effort">Migration Effort</h3>
<p>When a test program does upgrade to a major version with incompatible changes:</p>
<ul>
<li>The update is deliberate and controlled by the test program team</li>
<li>Only the specific test program being updated is affected</li>
<li>The scope of changes is typically smaller than in IG-XL platform updates</li>
<li>Test program source code provides full visibility into required modifications</li>
</ul>
<p>This makes the compatibility challenge more manageable compared to platform-level updates where all programs must adapt simultaneously.</p>
<h2 id="key-differences-from-the-previous-model">Key Differences from the Previous Model</h2>
<p>C#RA previously used a versioned interface approach where multiple API versions (V1, V2, etc.) existed side-by-side within the same release. This model has been replaced with the simpler approach described above.</p>
<h3 id="what-remains-the-same">What Remains the Same</h3>
<ul>
<li>Version numbers (<code>Major.Minor</code>) continue to be used</li>
<li>Major version increments still indicate incompatible changes</li>
<li>Minor version increments still indicate compatible additions</li>
<li>The commitment to minimize breaking changes continues</li>
</ul>
<h3 id="what-has-changed">What Has Changed</h3>
<p>The versioned interface indirection (V1, V2 namespaces) has been removed:</p>
<ul>
<li><strong>Previous approach:</strong> Multiple API versions shipped together, accessed via <code>using Library_v1;</code> or <code>using Library_v2;</code></li>
<li><strong>Current approach:</strong> Single API version per release, with incompatible changes delivered through new major versions</li>
</ul>
<p>This change simplifies the library structure and reduces maintenance overhead without sacrificing compatibility for users. Test programs still work with their specific C#RA version, but the implementation is more straightforward.</p>
<h3 id="implications">Implications</h3>
<ul>
<li>Users will encounter incompatible updates when upgrading to new major versions</li>
<li>There will not be different release branches - development follows a single path forward</li>
<li>The migration effort is manageable because test programs control when and if they upgrade</li>
<li>The problem is less complex than IG-XL platform updates where all programs must adapt simultaneously</li>
</ul>
<p>The new model trades the ability to run multiple API versions in a single program for simplicity in library structure and maintenance. Since test programs embed specific C#RA versions and rarely need to mix API generations, this tradeoff favors practical usability.</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>© 2024 - <span id='currentYear'></span> Teradyne - Generated by <a href="https://dotnet.github.io/docfx">DocFx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
