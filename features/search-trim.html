<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Search &amp; Trim Tests | C# Reference Architecture </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Search &amp; Trim Tests | C# Reference Architecture ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/TER-SEMITEST-InnerSource/cs-reference-architecture/blob/main/docs/features/search-trim.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../media/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="search--trim-tests">Search &amp; Trim Tests</h1>

<p>Certain device parameters cannot be directly measured and instead require indirect test methods. The test conditions are applied to the device, and the resulting effects - often observed on different pins - are analyzed. The goal is to identify either a tripping point that marks a sudden change in behavior or the input condition that brings the device closest to its ideal performance. Examples include input thresholds, trim parameters, and valid ranges for supply voltages or operating frequencies.</p>
<p>Determining such points typically requires an iterative approach. Even with an ideal tester, the DUT (Device Under Test) itself limits how quickly tests can be executed, making these tests relatively expensive. Extensive searches are often performed during device characterization, while only the most critical ones are retained for production. Once behavior has been thoroughly verified and the production process is stable, these tests are often replaced by faster go/no-go checks. Reducing resolution (i.e., accuracy) is another way to improve test throughput.</p>
<h2 id="flavors">Flavors</h2>
<p>There is a wide variety of parameters and methods that fall into this category. Below are a few commonly encountered ones.</p>
<h3 id="functional-vs-parametric">Functional vs. Parametric</h3>
<p>Device behavior may be observed using either functional tests or parametric measurements. While the test approach is largely similar, parametric results are typically pin-based and produce numerical (integer or floating-point) values, whereas functional results are usually binary (pass/fail) patterns.</p>
<h3 id="search-vs-trim">Search vs. Trim</h3>
<p>Trim tests are essentially a specialized form of search. For improved accuracy or performance, some devices allow post-manufacture adjustments via fuse blowing or non-volatile memory programming. A standard search strategy is used to find the optimal trim setting, after which the device is permanently altered.</p>
<h3 id="characterization--shmoo">Characterization &amp; Shmoo</h3>
<p>There is a smooth transition between characterization and production testing, as well as between the techniques used. Characterization emphasizes accuracy, often at the cost of speed, while production testing tends to trade off resolution for throughput. Shmoo plots provide a graphical representation of search results, typically in two or three dimensions.</p>
<h2 id="algorithms">Algorithms</h2>
<p>Various search algorithms have emerged depending on DUT characteristics and tester capabilities. Each has its place and may be used interchangeably for comparison or optimization.</p>
<h3 id="linearstop">LinearStop</h3>
<p>This strategy starts at one end of the range and increments linearly until the desired condition is met. The search is then halted to avoid unnecessary steps. While simple, this approach can be slow and inefficient - especially in multi-site setups - since the full range must be traversed even when the result lies near the opposite end. It works well when the number of steps is small or when device behavior is highly non-linear or otherwise unsuitable for more advanced strategies. It can also serve as a baseline method during early device evaluation.</p>
<p><img src="media/search-linear.png" alt="Graph showing linear search strategy starting from one end and incrementing step by step until the target condition is met, then stopping"></p>
<p>Since this is an interactive algorithm, it makes real-time decisions based on measurements at each step. This can introduce stalls in pipelined tester architectures.</p>
<h3 id="linearfull">LinearFull</h3>
<p>In contrast to LinearStop, this method runs the entire linear ramp regardless of when the condition is met. This can be advantageous for pipelined testers that benefit from deferred measurement processing. If the ramp dynamics are known and consistent, it’s possible to read back the full result set efficiently after ramp execution.</p>
<p><img src="media/search-linear-full.png" alt="Graph showing linear full search strategy executing the complete ramp regardless of when condition is met, optimized for pipelined testers"></p>
<p>This method is suited to low- to medium-resolution features with manageable DUT settling times. If the settling is slow but predictable, it can be modeled and compensated for.</p>
<h3 id="binarysearch">BinarySearch</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Binary_search">binary search algorithm</a> significantly reduces the number of steps required - from <code>n</code> to <code>log(n)</code> compared to a linear search. It is an interactive approach that divides the search space in half at each step, evaluating whether the condition lies above or below the midpoint.</p>
<p><img src="media/search-binary.png" alt="Graph illustrating binary search algorithm dividing search space in half at each step, reducing steps from n to log(n) compared to linear approaches"></p>
<p>However, this method can be challenging to implement across multiple sites and pins. Each channel requires independent force conditions, limiting the use of broadcast mode. Random noise or hysteresis may reduce repeatability and reproducibility.</p>
<p><img src="media/search-binary-uni.png" alt="Graph showing unidirectional binary search approach to avoid hysteresis issues, ensuring consistent search direction for better repeatability"></p>
<p>Devices with <a href="https://en.wikipedia.org/wiki/Hysteresis">hysteresis</a> may exhibit bi-modal outcomes due to the search approaching from inconsistent directions. This can be avoided by enforcing a unidirectional search.</p>
<h3 id="polynomial-and-curve-fitting-methods">Polynomial and Curve Fitting Methods</h3>
<p>When a device’s transfer function is known or can be reliably modeled, a few strategically selected measurements may suffice to estimate the entire response curve.</p>
<ul>
<li><p><strong>Exact Polynomial Interpolation</strong> - this method constructs a polynomial of degree n – 1 that passes exactly through n known data points. It guarantees that all measured points are precisely matched. However, this precision comes at a cost: the resulting curve can become unstable or oscillatory, especially when using high-degree polynomials or noisy data (a phenomenon known as Runge’s phenomenon). This approach is best used when the number of data points is small and measurements are highly reliable.</p>
</li>
<li><p><strong>Best-Fit Curve Approximation</strong> - instead of requiring the curve to pass through all data points exactly, this method fits a chosen function type (e.g., linear, quadratic, exponential) to the data using regression techniques. The result is an approximate model that minimizes the overall deviation from the measured values (e.g., via least squares). While not exact at any given point, this approach is generally more stable and tolerant of noise, making it well suited for gradual, continuous behaviors.</p>
</li>
</ul>
<p>These modeling techniques are effective in applications such as trim tests, where the device response is smooth and predictable. They are not suitable for discontinuous behaviors like functional tests or threshold searches, where abrupt transitions cannot be accurately represented by interpolation or smooth curve fitting.</p>
<h3 id="exotic-algorithms">Exotic Algorithms</h3>
<p>Some devices limit access to internal features or expose other constraints that require more specialized search strategies. When compatible with the overall design pattern, these can be integrated using C#RA’s customization features.</p>
<h4 id="history-based-start-points">History Based Start Points</h4>
<p>If the process is stable and well understood, starting a search from the extremes may be inefficient. Instead, the previous result(s) can serve as a statistical predictor for the current DUT. Searching in alternating directions from this point with increasing resolution can reduce total steps. However, this approach requires persistent data handling beyond a single test program run and individualized force conditions per site/pin.</p>
<h4 id="coarse--fine">Coarse / Fine</h4>
<p>High-resolution ramps can be divided into coarse and fine phases. The coarse step identifies the general region, while the fine step zeroes in with greater accuracy. This is essentially a hybrid between linear and binary search strategies, where each step improves resolution by a factor (typically two).</p>
<h4 id="continuous-ramp">Continuous Ramp</h4>
<p>Inspired by converter testing at larger resolutions, sticking with a discrete ramp (direct association of every individual step) may become inefficient. Instead, the ramp may be provided as a truly continuous input signal. If the device's detection logic is non-discrete, its response can continuously observed and used as a trigger to detect the source condition, or captured for post-processing. Propagation delay errors - proportional to ramp speed - can be modeled and compensated.</p>
<h4 id="fastramp-with-individual-verify">FastRamp With Individual Verify</h4>
<p>To compensate for potential inaccuracies from faster ramps (discrete or continuous), a few steps before and after the detected point can be retested for confirmation. If the threshold cannot be verified within tolerance, the device may be binned out.</p>
<h4 id="binlin--linbin">BinLin / LinBin</h4>
<p>BinLin is very similar to the Course / Fine strategy. The Course region typically conducts a binary search. Since things like hysteresis create improper convergence and inconsistencies across sites, it's only used to get within range. From there, the Fine region is conducted using a linear search with much fewer steps than the LinearStop or LinearFull algorithm.</p>
<p>It's currently unclear how LinBin would actually be used.</p>
<h4 id="built-in-search--trim-tests">Built-In Search &amp; Trim tests</h4>
<p>Devices may have built-in methods to detect and determine such parameters. What they need to execute that may vary significantly and range from applying precise reference voltage from external to loading executable code into the chip memory and execute pattern to run the algorithm and capture the results.</p>
<p>Those tests are out of scope for this task, as they typically don't use the logic provided here. Instead, they typically use standard features available via different test blocks.</p>
<h4 id="asynchronous-trigger">Asynchronous Trigger</h4>
<p>Certain instruments allow using a hardware trigger input to determine the stop condition for a signal sourced, like DCVI with DCTime, HVD with EventStamper. To find an input threshold value in that mode, a ramp is sourced to the DUT input, while the output is connected so that a condition change either stops the source signal or records the current force value. This technique can run fully autonomously in the hardware, and the results are read back as the last forcing value from the instruments, specific to multiple sites and pins.</p>
<h2 id="guidelines">Guidelines</h2>
<p>The following guidelines have been captured in the design phase and followed during implementation:</p>
<ul>
<li>different search algorithms share common use model and share parameter names for same (similar) features</li>
<li>execution performance is a critical goal</li>
<li>functional &amp; parametric tests share common implementation</li>
<li>user interfaces are not over-burdened with superset of parameters only relevant for a single algorithm</li>
<li>the risk of over-engineering is mitigated</li>
<li>C# / .NET type safety is respected</li>
<li>various input &amp; output types are supported (int, double, bool and going forward - as IG-XL adds support - uint, long, ulong, ...)</li>
</ul>
<h2 id="code-structure">Code Structure</h2>
<p>Consistent with the core principle of the C#RA, instrument agnostic abstraction language is offered that allows flexible re-use for the common cases and easy extension where custom aspects need to be considered. Due to the broad nature of search &amp; trim tests, the focus is at the test block level, to be used to compose test methods suitable for a specific test. The test methods offered and implemented on the demo device follow that strategy, they may be directly reused where they fit or serve as a blueprint if different requirements exist.</p>
<p>The choice of this architecture was only made after controversial discussions. Eventually, it was found that the benefits outweigh the following downsides:</p>
<ul>
<li>algorithm encoded in test blocks, so test methods will have to select one</li>
<li>test methods provided and shipped with C#RA are likely not &quot;ready-to-use&quot; for large majority of applications</li>
<li>instead, they serve as template code for &quot;roll-your-own&quot;</li>
<li>code uses advanced C# language concepts like delegates and generics.</li>
</ul>
<h3 id="example-test-case-parametric-threshold-search">Example Test Case: Parametric Threshold Search</h3>
<p>The following test method will determine the input threshold at which the output of the device switches. It'll perform a full ramp where the device's response is captured in every step:</p>
<pre><code class="lang-cs">[TestMethod, Steppable, CustomValidation]
public void LinearFull_ReadEach(PinList inputPins, PinList outputPins, double voltageFrom, double voltageTo, int stepCount, double outputThreshold, double stepSettleTime, string setup = &quot;&quot;) {

    if (TheExec.Flow.IsValidating) {
        _inputPins ??= new Pins(inputPins);
        _outputPins ??= new Pins(outputPins);
    }

    if (ShouldRunPreBody) {
        TheLib.Setup.LevelsAndTiming.Apply();
        Services.Setup.Apply(setup);
        TheLib.Setup.Dc.Connect(_inputPins, true);
        TheLib.Setup.Dc.Connect(_outputPins, true);
    }

    if (ShouldRunBody) {
        TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
        TheLib.Setup.Dc.ForceHiZ(_outputPins);
        double increment = TheLibX.Acquire.Search.LinearFullFromToSteps&lt;double&gt;(voltageFrom, voltageTo, stepCount, ForceAndRead);
        _tripVoltage = TheLibX.Acquire.Search.LinearFullProcess(measurements, voltageFrom, increment, 0, -999, m =&gt; m &gt; outputThreshold);
    }

    if (ShouldRunPostBody) {
        TheLib.Setup.Dc.Disconnect(_inputPins, false);
        TheLib.Setup.Dc.Disconnect(_outputPins, false);
        TheLib.Datalog.TestParametric(_tripVoltage, voltageFrom);
    }

    void ForceAndRead(double inValue) {
        TheLib.Setup.Dc.ForceV(_inputPins, inValue);
        TheHdw.SettleWait(stepSettleTime);
        measurements.Add(TheLib.Acquire.Dc.Measure(_outputPins));
    }
}
</code></pre>
<p>The <code>Validating</code>, <code>PreBody</code> and <code>PostBody</code> sections perform the normal and typical data preparation, setup, reset and datalog actions - they are not further explained here.</p>
<p>The <code>Body</code> section starts by preparing the instrument setups on the device's inputs and outputs. A data container <code>List&lt;PinSite&lt;double&gt;&gt; measurements</code> is prepared to hold each step's output. Then, the test block <code>TheLib.Acquire.Search.LinearFullSweepFromTo</code> performs the complete ramp sweep according to the input parameters.</p>
<p>The last parameter is a delegate to the method to be performed for every, which only takes the current force value as an input parameter.</p>
<p>Local methods have access to all local variables and class fields, which is a great benefit. The <code>_inputPins</code>, <code>stepSettleTime</code> and <code>measurement</code> container for the results don't have to be passed in as arguments, but can be directly used. This makes the concept very generic, as it avoids impacting the argument signature of the test block. That can follow a flexible design with the ramp control parameters being generic:</p>
<pre><code class="lang-cs">internal static Tin LinearFullFromToSteps&lt;Tin&gt;(Tin from, Tin to, int steps, Action&lt;Tin&gt; oneStep) {
    dynamic inValue = from;
    dynamic increment = (to - inValue) / (steps + 1);
    for (int i = 0; i &lt; steps; i++) {
        oneStep(inValue);
        inValue += increment;
    }
    return increment;
}
</code></pre>
<p>Overloads are offered for alternative ramp definition models to take calculations off of users shoulders:</p>
<pre><code class="lang-cs">public static void LinearFullFromToInc&lt;Tin&gt;(Tin from, Tin to, Tin increment, Action&lt;Tin&gt; oneStep) {  .. }

public static void LinearFullFromIncSteps&lt;Tin&gt;(Tin from, Tin increment, int steps, Action&lt;Tin&gt; oneStep) {  .. }
</code></pre>
<p>Finally, the collected measurements are processed to find the tripping point. This is done by the <code>TheLib.Acquire.Search.LinearFullProcess</code> test block, executed as a separate step after the ramp has completed. It uses a <code>Func&lt;double, bool&gt;</code> delegate to describe the criteria, in this case when the <code>outputThreshold</code> is exceeded.</p>
<pre><code class="lang-cs">public static PinSite&lt;Tin&gt; LinearFullProcess&lt;Tin, Tout&gt;(List&lt;PinSite&lt;Tout&gt;&gt; measurements, Tin from, Tin increment, Tin offset, Tin notFoundResult, Func&lt;Tout, bool&gt; tripCriteria) {
    PinSite&lt;int&gt; tripIndex = measurements.First().Select(ps =&gt; -1); // Clone the structure of the first measurement
    ForEachSite(site =&gt; { // this could be done with a convoluted &amp; unreadable LINQ statement
        for (int index = 0; index &lt; measurements.Count; index++) {
            for (int pin = 0; pin &lt; tripIndex.Count; pin++) {
                if (tripIndex[pin][site] == -1 &amp;&amp; tripCriteria(measurements[index][pin][site])) tripIndex[pin][site] = index;
            }
        }
    });
    return tripIndex.Select(t =&gt; t &gt; -1 ? (Tin)(t * (dynamic)increment + from + offset) : notFoundResult);
}
</code></pre>
<h3 id="lambda-expressions">Lambda expressions</h3>
<p>Instead of a named method, lambda expressions (<code>inValue =&gt; ...</code>) may be used to pass in the code to be executed per step, following the same notation IG-XL proposed for <code>ForEachSite()</code> loops.</p>
<pre><code class="lang-cs">List&lt;PinSite&lt;double&gt;&gt; measurements = new();

//if (TheExec.Flow.IsValidating) { ... }      //if (ShouldRunPreBody) { ... }

if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    List&lt;PinSite&lt;double&gt;&gt; measurements = new();
    double increment = TheLibX.Acquire.Search.LinearFullFromToSteps&lt;double&gt;(voltageFrom, voltageTo, stepCount, inValue =&gt; {
        TheLib.Setup.Dc.ForceV(_inputPins, inValue);
        TheHdw.SettleWait(stepSettleTime);
        measurements.Add(TheLib.Acquire.Dc.Measure(_outputPins));
    });
    _tripVoltage = TheLibX.Acquire.Search.LinearFullProcess(measurements, voltageFrom, increment, 0, -999, trip =&gt; trip &gt; outputThreshold);
}

//if (ShouldRunPostBody) { ... }
</code></pre>
<p>This notation may be preferable for cases where the delegate code is not too complex or convoluted. There is a little learning curve with the lambda expressions syntax (<code>=&gt;</code>), so that teams at the beginning of the learning curve with C# may prefer explicit methods instead.</p>
<div class="NOTE">
<h5>Note</h5>
<p>There is no functional or performance difference between lambda expressions or named local methods. The compiler will actually turn this into the exact same IL code.</p>
</div>
<h3 id="public-methods">Public Methods</h3>
<p>Only where non-local methods are desired, the local context needs to be handed through parameters:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    List&lt;PinSite&lt;double&gt;&gt; measurements = new();
    double increment = TheLib.Acquire.Search.LinearFullSweepFromTo&lt;double&gt;(voltageFrom, voltageTo, stepCount, inValue =&gt;
        CentralMethodsSomewhereElse.OneStepReadCollect(_inputPins, _outputPins, inValue, stepSettleTime, measurements));
    _tripVoltage = TheLib.Acquire.Search.LinearFullProcess(measurements, voltageFrom, increment, 0, -999, m =&gt; m &gt; outputThreshold);
}
</code></pre>
<h3 id="read-all-results-in-once">Read All Results In Once</h3>
<p>In this example the measurements per step are only strobed, and then read back in a single shot after the ramp completes:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    double increment = TheLibX.Acquire.Search.LinearFullFromToSteps&lt;double&gt;(voltageFrom, voltageTo, stepCount, ForceAndStrobe);
    PinSite&lt;Samples&lt;double&gt;&gt; measurements = TheLib.Acquire.Dc.ReadMeasuredSamples(_outputPins, stepCount);
    _tripVoltage = TheLibX.Acquire.Search.LinearFullProcess(measurements, voltageFrom, increment, 0, -999, trip =&gt; trip &gt; outputThreshold);
}

void ForceAndStrobe(double inValue) {
    TheLib.Setup.Dc.ForceV(_inputPins, inValue);
    TheHdw.SettleWait(stepSettleTime);
    TheLib.Acquire.Dc.Strobe(_outputPins);
}
</code></pre>
<p>The exact same test blocks can be used to achieve this. The per-step-action performs a <code>Dc.Strobe</code> only and a dedicated statement reads the measured samples after completion. An overload is offered for the processing block to support the slightly different result object structure <code>PinSite&lt;Samples&lt;double&gt;&gt;</code>. This model is also suitable for embedded DSP processing for best performance and full backgrounding.</p>
<h3 id="linearfull-with-functional-result">LinearFull with Functional Result</h3>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLibX.Acquire.Search.LinearFullFromToInc&lt;double&gt;(start, stop, increment, FuncStep);
    _tripVoltage = TheLibX.Acquire.Search.LinearFullProcess(_measurementsPs, start, increment, 0, -999, trip =&gt; trip);
}

void FuncStep(double inValue) {
    TheLib.Setup.Dc.ForceV(_pins, inValue);
    TheLib.Execute.Digital.RunPattern(_pattern);
    _measurementsPs.Add(new PinSite&lt;bool&gt;(TheLib.Acquire.Digital.PatternResults()));
}
</code></pre>
<p>Functional test results can be handled with <code>bool</code> as the output type. Since pattern results are not per pin, <code>Site&lt;bool&gt;</code> may be used instead.</p>
<h3 id="linearstop-algorithm">LinearStop Algorithm</h3>
<p>A different search algorithm can be applied by simply switching the test block to the <code>TheLib.Acquire.Search.LinearStopFromTo</code> block:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    _tripVoltage = TheLibX.Acquire.Search.LinearStopFromToSteps&lt;double, double&gt;(voltageFrom, voltageTo, stepCount, 0, -999, ForceAndRead,
        m =&gt; m &gt; outputThreshold);
}

PinSite&lt;double&gt; ForceAndRead(double inValue) {
    TheLib.Setup.Dc.ForceV(_inputPins, inValue);
    TheHdw.SettleWait(stepSettleTime);
    return TheLib.Acquire.Dc.Measure(_outputPins);
}
</code></pre>
<p>It follows the same use model, but instead of a separate processing step, it directly returns the result. This is a benefit of the interactive search algorithms, however at the cost of stalling the pipeline.</p>
<h3 id="binarysearch-1">BinarySearch</h3>
<p>In the same way, a binary search can be used thought the test block <code>TheLib.Acquire.Search.BinarySearch</code>:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    _tripVoltage = TheLibX.Acquire.Search.BinarySearch&lt;double, double&gt;(voltageFrom, voltageTo, minDelta, false, -999, ForceAndRead,
        m =&gt; m &gt; outputThreshold);
}

PinSite&lt;double&gt; ForceAndRead(PinSite&lt;double&gt; inValue) {
    //TheLib.Setup.Dc.ForceV(_inputPins, level); // no multi-pin / multi-site flavor available yet
    TheHdw.SettleWait(stepSettleTime);
    return TheLib.Acquire.Dc.Measure(_outputPins);
}
</code></pre>
<h3 id="binarysearch-unidirectional">BinarySearch unidirectional:</h3>
<p>To avoid hysteresis problems, a modified binary search concept can make sure to always approach the levels from the same direction:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    _tripVoltage = TheLibX.Acquire.Search.BinarySearch&lt;double, double&gt;(voltageFrom, voltageTo, minDelta, false, -999, ForceAndRead,
        m =&gt; m &gt; outputThreshold);
}

PinSite&lt;double&gt; ForceAndRead(PinSite&lt;double&gt; inValue) {
    //TheLib.Setup.Dc.ForceV(_inputPins, level); // no multi-pin / multi-site flavor available yet
    TheHdw.SettleWait(stepSettleTime);
    var meas = TheLib.Acquire.Dc.Measure(_outputPins);
    TheLib.Setup.Dc.ForceV(_inputPins, voltageFrom);
    TheHdw.SettleWait(stepSettleTime);
    return meas;
}
</code></pre>
<p>This is achieved by modifying the single step lambda expression to return back to the starting point after each measurement. The test block itself is agnostic and can be used without change.</p>
<h3 id="trim-test-using-linearfull">Trim Test using LinearFull</h3>
<p>Again without modification, the test blocks support trim tests:</p>
<pre><code class="lang-cs">if (ShouldRunBody) {
    RegisterWrite(from);
    TheLib.Setup.Dc.ForceHiZ(_outputPins);
    TheLibX.Acquire.Search.LinearFullFromToInc&lt;int&gt;(from, to, 1, ForceAndRead);
    _trimCode = TheLibX.Acquire.Search.LinearFullProcess(measurements, from, 1, 0, -999, trip =&gt; trip &gt; target);
}

void ForceAndRead(int inValue) {
    RegisterWrite(inValue);
    TheHdw.SettleWait(stepSettleTime);
    measurements.Add(TheLib.Acquire.Dc.Measure(_outputPins));
}
</code></pre>
<p>In this case the input type is <code>int</code> for the trim code. Instead of a threshold, the trip criteria is specified by the output value exceeding the trim target, but alternative concepts (last step BEFORE switch, minimum absolute deviation, ...) are possible. Where alternative strategies are required (LinearFull_ReadAll, LinearStop, BinarySearch, ...), the respective test blocks can be used instead.</p>
<h2 id="options">Options</h2>
<p>Flexibiltiy is required to suit the various use cases captured for this wide range of test techniques. Test blocks are overloaded for:</p>
<ul>
<li>Ramp Definition
<ul>
<li><code>from</code>, <code>increment</code>, <code>steps</code> - specify start point, step size and count</li>
<li><code>from</code>, <code>to</code>, <code>increment</code> - specify start point, end point and step size</li>
<li><code>from</code>, <code>to</code>, <code>steps</code>- specify start point, end point and step count</li>
</ul>
</li>
<li>Search Criteria
<ul>
<li><code>target</code> - output value that should be matched closely</li>
<li><code>tripCriteria</code> - delegate to indicate inflection point</li>
</ul>
</li>
<li>Results
<ul>
<li><code>inValue</code> - best input for the desired output (method return)</li>
<li><code>index</code> - ramp index for identified best input (out parameter)</li>
<li><code>outValue</code>- actual output value for identified best input (out parameteR)</li>
</ul>
</li>
</ul>
<h2 id="alternatives-considered">Alternatives Considered</h2>
<h3 id="search--trim---a-vibrant-domain">Search &amp; Trim - A Vibrant Domain</h3>
<p>A variety of user preferences, flavors, concepts and styles exist for what is considered &quot;the best&quot; approach to this domain. Despite intense discussions and prototyping, it was difficult to agree on a single concept to move forward with this. Undeniably, all of the propose alternatives have other benefits and / or solve a particular aspect more elegantly. The proposal above was determined in team voting as the most reasonable compromise to move forward.</p>
<p>The alternative ideas are shown here to allow closing the loop on how well the chosen path turns out to be a viable solution. A implementation proceeds, regular check-steps confirm whether design choices work out. Should the chosen path run into a road-block, alternatives may be revived quickly.</p>
<h4 id="flat-algorithm-in-test-method">Flat Algorithm in Test Method</h4>
<p><img src="media/search-flat.png" alt="Code structure diagram showing flat algorithm implementation directly in test method with straightforward loop mechanics for easy debugging and understanding"></p>
<p>This is the most straight-forward approach, showing the loop mechanics right in the test method. Users would not have to jump to different places when stepping through, everything would be very easy to follow.</p>
<p>Advanced code concepts like delegates and generics are avoided at the cost of specific implementations for the given task.</p>
<p>Especially for more complex algorithms, this approach could result in complex test methods. There's little encapsulation or reuse applied.</p>
<h4 id="delegates-by-name">Delegates by Name</h4>
<p><img src="media/search-delegate-by-name.png" alt="Code architecture diagram showing delegate-by-name approach enabling flexible algorithm selection through test method input parameters for generic implementations"></p>
<p>This approach may be the plan-of-record when truly generic test methods are desired, where users can flexibly select the algorithm as a test method input parameter.</p>
<p>The generalization comes at the cost of some overhead and limitations in typing, which may be acceptable where flexibility is required.</p>
<h4 id="serch-by-conditionlist">Serch by ConditionList</h4>
<p><img src="media/search-conditionlist-1.png" alt="Step 1 of ConditionList search approach showing initial setup and condition definition for generic search algorithm implementation"></p>
<p><img src="media/search-conditionlist-2.png" alt="Step 2 of ConditionList search approach demonstrating condition evaluation and search progression within the generic model framework"></p>
<p><img src="media/search-conditionlist-3.png" alt="Step 3 of ConditionList search approach showing intermediate search state with condition tracking and history preservation"></p>
<p><img src="media/search-conditionlist-4.png" alt="Step 4 of ConditionList search approach illustrating continued search iteration with comprehensive step tracking and traceability"></p>
<p><img src="media/search-conditionlist-5.png" alt="Step 5 of ConditionList search approach showing final search completion with complete history and results available for plotting or analysis"></p>
<p>This approach has the benefit of strictly following a single, generic model for any search. All steps are present, which can help when a search history would need to be traced or plotted.</p>
<p>Some concerns were raised on the resulting code complexity oin the test blocks. Even though additional algorithms could be implemented in a very concise way, there was some learning investment for the first. Users only wishing to step through the existing code might find it challenging to understand. The generalization may result in dictionary types being a little intransparent on the meaning of their contents.</p>
<h3 id="the-all-in-one-test-method">The All-In-One Test Method</h3>
<p>It's expected that test methods require some modifications / adjustments to the specific device in most cases. The variety of conditions and parameters is just too broad. Offering a variety of specialized test methods templates as starting point for customization is considered better than an overly generic one with significant complexity.</p>
<p>That doesn't get in the way of offering overlapping functionality like with a dedicated functional Vmin test method that allows choosing between linear and binary search, if there are tangible use cases and reasonable functional scope can be determined.</p>
<h3 id="adjust">Adjust</h3>
<blockquote>
<p>TODO</p>
<p>IG-XL's Adjust Service (?) offers similar services and may be used to achieve the same. It's currently not clear if and how that is an option, or if only concepts and ideas should be reused.</p>
</blockquote>
<h3 id="multi-pin">Multi-Pin</h3>
<p>The original concept envisioned a multi-pin model with single pin being only a special case. It turned out that this would heavily complicate implementation with a very questionable benefit. Independent but simultaneous searches on multiple input --&gt; output paths within the same device are a very rare case.</p>
<p>It was decided to use a single-pin model for searches.</p>
<h2 id="questions">Questions</h2>
<ul>
<li>POP for linear full?</li>
</ul>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>© 2024 - <span id='currentYear'></span> Teradyne - Generated by <a href="https://dotnet.github.io/docfx">DocFx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
