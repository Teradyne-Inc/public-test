<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Persistent Data Storage | C# Reference Architecture </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Persistent Data Storage | C# Reference Architecture ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/TER-SEMITEST-InnerSource/cs-reference-architecture/blob/main/docs/features/persistent-data-storage.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../media/logo.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="persistent-data-storage">Persistent Data Storage</h1>

<p>Test programs frequently have a need to store data beyond the lifetime of a single test instance. Although some of that information has a test program global scope, in many cases there's a strong association between the data and a specific test method. Examples include:</p>
<ul>
<li><p><strong>Caching expensive (local) data:</strong> In IG-XL, test methods are called from the flow with the test instance properties being handed as arguments. Historically, test methods didn't encourage using state, they were rather considered static, stateless methods. IG-XL is optimized for efficient data handling from its internal caches to the test method (<strong>NOT</strong> repetitively reading from the sheet at run time!).<br><br>However, the supported data types are limited to basic ones (<code>string</code>, <code>int</code>, <code>bool</code> and <code>double</code>). More complex information (arrays, data structures) must either be encoded in strings or referenced via a key, so that it can be looked up elsewhere. Input data that requires further processing (like generic test methods having to resolve input pin lists and query the instrument types) can't easily cache the results, since it may be called multiple times in the same flow with different arguments.<br><br>Repeated re-creation or re-evaluation directly impacts production throughput, unless users find a way to skip that in sub-sequent runs.</p>
</li>
<li><p><strong>Reuse data later in the flow:</strong> Some test concepts involve the (expensive) acquisition of device specific data once, and reuse that multiple times further along on the flow. Such data needs to be reliably re-initialized at the test program start to avoid information leakage to the next DUT. Calibration data (focus, ground) or trimming information fall into this category.</p>
</li>
<li><p><strong>Aggregate data across devices:</strong> Certain test techniques involve deliberate information leakage across devices. For instance could a part-average-testing approach dynamically adjust its limits based on the typical behavior of previous devices, so that process outliers are found sooner. Test time optimizations for trim tests could consider the results of the previous DUTs to start with the most-likely result in order to minimize the steps needed.</p>
</li>
</ul>
<p>In all these cases, flexible data storage is required, with awareness of IG-XL events (validation, program start &amp; end, ...) for a robust and reliable solution.</p>
<h2 id="concept">Concept</h2>
<p>C#RA adheres to the principle of modularity and encapsulation. Data is stored with the minimum necessary scope and accessibility, preferably bundled into classes providing specific properties and methods to interact with it.</p>
<p>Test Methods are the main place to hold and manage test related data. Test blocks (stateless) receive this data as arguments, and return any results back into the test method for further processing.</p>
<p>Data local to the test method or test class that needs to survive beyond the test instance execution is captured in class fields, with the test class marked with the <code>Creation.Once</code> or <code>Creation.TestInstance</code> attribute. These make sure that IG-XL re-uses objects instead of creating new, resulting in persistence for any class fields. Access to such data from other test methods is made through an IG-XL API that returns a reference to an instance's test class object.</p>
<p>Key based data storage and retrieval is provided through a dedicated <strong>PersistentStorageService</strong>. Even though this is only needed in certain scenarios, an efficient &amp; robust design is offered to provide a reliable, ready-to-use solution, saving users the effort of implementing their own (see chapter <a href="#persistent-storage-service">Persistent Storage Service below</a>)</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>C#RA will have persistent storage that users can take advantage of, but it will not store anything in persistent storage by default, users have to opt in and should review the downsides to this storage and minimize it's use to necessities.</p>
</div>
<h2 id="background">Background</h2>
<h3 id="vba">VBA</h3>
<p>In VBA, data persistence is typically achieved via module-level variables, which are the equivalent of static class fields in .NET. With scope options limited to <code>private</code> and <code>public</code> (= &quot;global&quot;), basic access control can be implemented. The concept of local static variables in methods may be useful, but can result in poor reusability and maintainability.</p>
<p><img src="media/storage_gv.png" alt="Code example showing VBA-style global variables (GV) used for data persistence, demonstrating public and private module-level variable declarations"></p>
<p>There's no limitation in types and no resulting execution time overhead for persistence. The lack of namespaces and effective encapsulation concepts results in convoluted code that violates modularity concepts and bypasses effective data &amp; access protection.</p>
<p>In larger teams and programs, or in code reuse scenarios, these limitations repeatedly cause friction and scalability issues.</p>
<h3 id="net">.NET</h3>
<p>The .NET languages are designed to manage large software solutions, and bring strong concepts like namespaces and the focus on object-oriented principles. In conjunction with IG-XL test programs, a few additional aspects need to be considered:</p>
<ul>
<li>Unlike in stand-alone tools (like .NET console apps), the concept of &quot;running&quot; code isn't bifold: .NET assemblies are loaded into the Excel process and &quot;run&quot; together with that, even before a job is started. For interactive scenarios, the debugger is &quot;running&quot;, and may keep that running state even after the test program has completed. The question of when objects and data containers are created, preserved, reset or destructed needs consideration.</li>
<li>Inter-process-communication is required in debug scenarios to synchronize data between the Excel and Debug Run Host process.</li>
</ul>
<div class="IMPORTANT">
<h5>Important</h5>
<p>For normal red-button program runs, .NET test code is loaded into the Excel process and executed there. Using the VisualStudio debugger in that scenario is possible, but has limitations: dynamic code edits are not allowed in breakpoints and the Excel UI and any debug displays are non-responsive (frozen), because the debugger halts the entire process.</p>
<p>For a truly interactive debug experience with debug displays, sheets and to support live code edits, jobs need to be started using the blue Debug-Run button. In that mode, IG-XL will execute .NET test code in a separate process (Debug Run Host or DRH). That process may be halted and even killed anytime without impacting the IG-XL runtime. Such increased flexibility however comes at the cost of overhead. The process needs to be launched, and data (all non-local variables) synchronized in both directions. IG-XL automatically takes care of that, but depending on the amount of data, this (debug only) overhead can become significant.</p>
</div>
<h3 id="encapsulation">Encapsulation</h3>
<p>One of the fundamental concepts of Object Oriented Programming (OOP) is data encapsulation. It's the exact opposite of a large &amp; global system state.</p>
<blockquote>
<p>&quot;Encapsulation in C# is the principle of bundling data (fields) and methods that operate on that data into a single unit (class) while restricting direct access to the internal state by using access modifiers like <code>private</code> or <code>protected</code>. This ensures controlled interaction with an object's state through public methods or properties, promoting data integrity and simplifying code maintenance.&quot;</p>
</blockquote>
<p>Encapsulating data in small and independent entities (classes) offering dedicated interfaces for interaction has benefits:</p>
<ul>
<li><strong>Data Protection:</strong> fine access control.  The class designer decides which parts shall or shall not be user accessible.</li>
<li><strong>Reuse:</strong> goes hand-in-hand with inheritance. Multiple objects of the same type can co-exist without the risk of interference.</li>
<li><strong>Modularity:</strong> features can be shared easily as they are contained and have fewer (or no) dependencies.</li>
<li><strong>Maintenance:</strong> clear ownership and scope (of code) and a single place to modify for code changes.</li>
<li><strong>Abstraction:</strong> functionality is available to users without the need for detailed understanding on how the data is stored / handled internally.</li>
<li><strong>Testability:</strong> fewer (or no) dependencies to system state, easier to simulate corner cases.</li>
</ul>
<h3 id="persistent-test-class-objects">Persistent Test Class Objects</h3>
<p>IG-XL itself uses a mix of programming paradigms, be that for historical reasons or for the fact that device test methodologies often follows a sequential, script-like approach. Some aspects in IG-XL are clearly object oriented (multi-site measurements, capture waveforms, ...), where others follow a more procedural style, like the concept of a Flow executing Test Instances, which call Test Methods. Finally, the use model around <code>DSPWave</code> expressions applies functional principles, where the output is a consequence of a chain of transforms on inputs without any side effects or external state involved.</p>
<p>.NET introduces the opportunity to better utilize object oriented tools.</p>
<p>In IG-XL, test methods are defined in non-static test classes. To execute a test method, an object has to be created. Static test classes are not supported as they would conflict with the concept of inheritance, which IG-XL TestMethods rely on. From IG-XL 11.00 on, users have a choice of three options for when (and how often) test class objects are created.</p>
<h4 id="creationalways---default-and-only-option-before-ig-xl-1100"><code>Creation.Always</code> - default and only option before IG-XL 11.00</h4>
<p>IG-XL will <strong>create a new test class object each time</strong> prior to calling it from the flow, objects are never stored or reused.<br><br>This model mimics the VBA approach, but does not allow for object data persistence, because once the test method has completed, the test class object (along with any local variables &amp; class level fields) is disposed off by the garbage collector (GC). Data requiring persistence must be stored elsewhere (breaks encapsulation).</p>
<h4 id="creationonce"><code>Creation.Once</code></h4>
<p>IG-XL will <strong>create a single object (aka &quot;Singleton&quot;) of the test class</strong> the first time it is accessed (Validation, First Run, ...) and reuse it whenever any test instance which uses the class is executed.<br><br>Data persistence is available at the class level, but data is common to all test instances using any of the test methods in the class, and shares the lifetime of the Excel process.<br><br>This option is well-suited for a collection of related test methods which benefit from a shared data set.</p>
<h4 id="creationtestinstance"><code>Creation.TestInstance</code></h4>
<p><strong>Separate objects of the test class are created for every test instance</strong> the first time each test instance is accessed (Validation, First Run, ...). Those objects are reused whenever their associated test instance is executed.<br><br>Non-static class level fields allow for fully encapsulated and independent data persistence for each test instance.'. Different test instance arguments can be pre-processed during validation, and the cached results are locally available for performant production runs. Data doesn't have to be sent and retrieved from somewhere, it's stored right at the place where it's created and processed. Class fields may be used for object (test instance) specific information, whereas static class fields allow sharing data across all objects.<br><br>This model works best for reusable test methods that benefit from out-sourcing some overhead or initialization to first run or validation.</p>
<h3 id="access-from-outside">Access from Outside</h3>
<p>The author/designer of a class retains fine control over external access. Data intended only for internal use would be defined as <code>private</code> fields and would allow no external access. Limited data access, like to only allow writing in certain ranges, or to perform calculations before reading back may go through <code>public</code> properties. Unconstrained access is possible when <code>public</code> fields are exposed directly (generally not recommended.)</p>
<p><img src="media/storage_api.png" alt="Class structure diagram showing API-based data access patterns with public properties, private fields, and controlled external access methods"></p>
<p>Because IG-XL manages test class objects (initial creation, re-creation on assembly updates), it's important to go through an IG-XL API when accessing such objects from the outside, like from other test methods:</p>
<p><code>Site&lt;int&gt; codeVbg = ((Trim)TheExec.TestProgram.TestCode.TestClassObjects.GetTestClassObject(&quot;TrimVbg&quot;, 0)).CodeVbg;</code></p>
<div class="NOTE">
<h5>Note</h5>
<p>The exact API language for this is still under review.</p>
</div>
<p>Attempts to manually cache this and avoid the IG-XL API is risky, and may result in hard-to-find errors when IG-XL re-created those objects and the cache still holds a reference to a stale object.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>This API does not open a back-door into IG-XL internals that shouldn't be accessed by users. Instead, it allows the fully OOP compliant use of test class objects. Because IG-XL creates those objects, the user doesn't have access from outside, only from inside.</p>
<p>Not offering this interface would invite users to create their own storage, somethine likw:</p>
<p><code>public static Dictionary&lt;string, TestCodeBase&gt; TestCodeObjects = new();</code></p>
<p>From inside a test method, users could place a handle to itself, and manage the accessors from outside that way:</p>
<p><code>TestCodeObjects.Add(TheExec.DataManager.InstanceName, this);</code></p>
<p>This is risky as IG-XL may re-creates their test class objects without being noticed by the cache, which would then still point to the old (stale) objects. Accessing those will result in hard-to-find errors. Besides, users would redundantly store information that already exists in IG.XL. Better offer read-access to the true source and avoid compromising test solution robustness.</p>
</div>
<h3 id="examples">Examples</h3>
<p>The first example shows how <code>Creation.TestInstance</code> is used to cache an object of the <code>Pins</code> class for a simple continuity test:</p>
<pre><code class="lang-cs">[TestClass(Creation.TestInstance)]
public class Continuity : TestCodeBase {

    private Pins _contPins;

    [TestMethod]
    public void Simple(string pinList, double current, double voltageRange, double waitTime, string dibConfig) {
        _contPins ??= new Pins(pinList);
        Setup.ApplyLevelsTiming();
        Setup.ApplyConfig(dibConfig);
        Setup.Dc.Connect(_contPins);
        Setup.Dc.ForceI(_contPins, current, Measure.Voltage, voltageRange, current);
        Execute.ChrisSuperWait(waitTime);
        PinSite&lt;double&gt; meas = Acquire.Dc.ReadMeter(_contPins);
        Setup.Dc.Disconnect(_contPins);
        Datalog.TestParametric(meas, &quot;V&quot;);
    }
}
</code></pre>
<p>The <code>new Pins(pinList)</code> constructor is only executed when the <code>_contPins</code> object is <code>null</code>, and then stored at the class level for this test instance. It goes through relatively expensive code that resolves the pin list and identifies the underlying instrument types behind every single pin. That object is used in the subsequent, instrument agnostic methods (test blocks) to perform the desired actions.</p>
<p>The second example presents a trim test utilizing the <code>Creation.Once</code> feature. The test method <code>VoltageBandgap()</code> sets up the device, performs a linear sweep through all trim codes and uses SiteGenerics expressions to determine the best trim code - which is stored in the class level field <code>_codeVbg</code>:</p>
<pre><code class="lang-cs">[TestClass(Creation.Once)]
public class Trim : TestCodeBase {

    private const int _defaultVbg = 7; // center value, until we know better
    private Site&lt;int&gt; _codeVbg = new(_defaultVbg);

    public Site&lt;int&gt; CodeVbg =&gt; _codeVbg;

    [ExecInterpose_OnProgramStarted]
    public void InitTrimValues() =&gt; _codeVbg.Fill(_defaultVbg);

    [TestMethod]
    public void VoltageBandgap(double targetV) {
        // connect resources
        // perform sweep
        Site&lt;Samples&lt;double&gt;&gt; cap = null; //readback all acquired strobes
        _codeVbg = cap.Select(s =&gt; {
            TerMath.Abs(s - targetV).Min(out int index);
            return index;
        });
        Datalog.TestParametric(_codeVbg);
        Datalog.TestParametric(cap.Select((m, site) =&gt; m[_codeVbg[site]]), &quot;mV&quot;);
    }
}
</code></pre>
<p>That field is defined as <code>private</code> so it can not be directly accessed from the outside. It can however be read via the read-only <code>public Site&lt;int&gt; CodeVbg =&gt; _codeVbg;</code> property. Additional logic is implemented, so that the trim code is re-initialized to it's default value on every program start (method <code>InitTrimValues()</code> decorated with attribute <code>[ExecInterpose_OnProgramStarted]</code>).</p>
<p>Now consider a general power-up function, which needs to write the &quot;currently best known trim code&quot; into the DUT. When called from the flow <strong>before</strong> trimming was executed, the default trim value shall be used. After trimming, the actual trim code (per site) is applied. Regardless of when this method is called, it'll always access the true data source:</p>
<pre><code class="lang-cs">[TestMethod]
public void PowerUp() {
    Setup.ApplyLevelsTiming();
    var vbgTrimObject = TheProgram.TestCode().TestClassObjects.GetObject&lt;Trim&gt;(trimVbgTestInstance);
    Site&lt;int&gt; code = vbgTrimObject.CodeVbg;
    Execute.Digital.WriteRegister(registerVbg, code);
}
</code></pre>
<p>.NET inherent access control as the class author defined it is maintained. Type mismatches or attempts to bypass is flagged by the compiler:</p>
<p><img src="media/test-class-object-access-compiler-checks.png" alt="Visual Studio compiler error highlighting access control violations when attempting to access private class members improperly"></p>
<h3 id="persistent-storage-service">Persistent Storage Service</h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>In this project, Object-Oriented Programming (OOP) is primarily used. However, there are corner cases where it is necessary to store generic information that does not belong to any specific object. To address this, a singleton data storage solution has been implemented using a <code>Dictionary&lt;string, object&gt;</code> with methods for unboxing to maintain type safety.</p>
<p><img src="media/storage_database.png" alt="Database-style storage service diagram showing Dictionary-based generic data storage with key-value pairs and type-safe unboxing methods"></p>
<h4 id="use-model">Use Model</h4>
<ul>
<li><strong>Initialization:</strong> The singleton instance is created and initialized at first use.</li>
<li><strong>Data Storage:</strong> The <code>Dictionary&lt;string, object&gt;</code> is used to store data. Methods are provided for adding, retrieving, and unboxing data to specific types.</li>
<li><strong>Access:</strong> The singleton instance can be accessed from anywhere in the application to store or retrieve data.</li>
</ul>
<h4 id="open-questions">Open Questions</h4>
<p>Even with great care, the following downsides still remain - and have to be accepted when used:</p>
<ul>
<li><strong>Performance Overhead:</strong> Boxing and unboxing add some performance overhead.</li>
<li><strong>Modularity:</strong> The use of a singleton can reduce modularity and make unit testing more challenging.</li>
<li><strong>Scalability:</strong> How will the data storage scale with increasing data and concurrent access?</li>
<li><strong>Integration:</strong> Need to create interfaces and manage integration into IG-XL ExecIp events.</li>
<li><strong>Debuggability:</strong> An additional level of indirection impacts debuggability, necessitating a debug-viewer for the contents.</li>
</ul>
<h3 id="alternatives-considered">Alternatives considered</h3>
<p>The following alternative was analyzed. In the overall assessment of the pros and cons they were considered less attractive than the proposed solutions for the reasons documented.</p>
<h4 id="use-of-global-net-variables">Use of <strong>Global .NET Variables</strong></h4>
<p>Being a little awkwardly named, <strong>Global .NET Variables</strong> do add persistence to objects in blue button runs involving the DRH process. Specifically, all serializable <code>public static</code> and <code>private static</code> objects are synchronized between the Excel and DRH process, so that the fundamental requirement of persistence is fulfilled.</p>
<p><img src="media/storage_gv.png" alt="Code example demonstrating Global .NET Variables implementation with static field declarations for cross-process data synchronization"></p>
<p>The limitation to <code>static</code> however collides with the requirement of storing data <strong>per test instance</strong>. The use case of caching local data from validation or first run in a test instance would not (easily) be possible. The model is good for data that needs to be shared across a test class, providing zero overhead for read and write access.</p>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Â© 2024 - <span id='currentYear'></span> Teradyne - Generated by <a href="https://dotnet.github.io/docfx">DocFx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
